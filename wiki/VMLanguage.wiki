#summary List of VM Commands
<wiki:toc max_depth="5" />

= VM Language =


= Details =

==Arithmetic==
|| *Command Keyword* || *Command* || *Arguments?* || *Description* ||
||ADD||Add||No||Add the top 2 values of the stack, then put result back onto stack||
||SUB||Subtract||No||Subtract the top of the stack from the value below it, then put result back onto stack||
||MUL||Multiply||No||Multiply the top 2 values of the stack, then put result back onto stack||
||DIV||Divide||No||Divide the 2nd value on the stack by the top one. Truncate and discard the remainder, then put result back onto stack||
||NEG||Negate||No||Negate the top of the stack||

==Boolean/Comparetors==
|| *Command Keyword* || *Command* || *Arguments?* || *Description* ||
||EQUAL||Equal||No||If the top two values on the stack are equal, push a 1; else push a 0||
||NOTEQL||Not Equal||No||If the top two values  on the stack are not equal push a 1; else push a 0||
||GREATER||Greater Than||No||If the top of the stack is greater than the value below it, push a 1; else push a 0||
||LESS||Less Than||No||If the top of the stack is less than the value below it, push a 1; else push a 0||
||GTREQL||Greater Than  or Equal To||No||If the top of the stack is greater than or equal to the value below it, push a 1; else push a 0||
||LSSEQL||Less than or Equal To||No||If the top of the stack is less than or equal to the value below it, push a 1; else push a 0||
||NOT||Not||No||If the top of the stack is 0 replace with a 1; else replace with a 0||

==Stack Manipulation==
|| *Command Keyword* || *Command* || *Arguments?* || *Description* ||
||PUSHC||Push Constant||Yes||Put the argument on the stack||
||PUSH||Push||Yes||Put the contents of the location specified by the argument on the stack (Argument Can be an actual memory value, a tag that matches a line of code or a variable)||
||POPC||Pop Constant||Yes||Put the top of the stack into the location specified by the argument. stack (Argument Can be an actual memory value, a tag that matches a line of code or a variable)||
||POP||Pop||No||Put the second value on the stack into the location specified by the top of the stack||
||CONTENTS||Contents||No||Replace the top of the stack with the contents of the location specified by the top of the stack||

==Control==
|| *Command Keyword* || *Command* || *Arguments?* || *Description* ||
||BRANCH||Branch||Yes||Set the program counter to the location specified by the argument. (Argument Can be an actual memory value, a tag that matches a line of code, or a variable)||
||JUMP||Jump||No||Set the program counter to the top of the stack||
||BREQL||Branch if Equal||Yes||If the top of the stack is 0, branch to the argument (Argument Can be an actual memory value, a tag that matches a line of code, or a variable)||
||BRLSS||Branch if Less Than||Yes||If the top of the stack is less than 0, branch to the argument (Argument Can be an actual memory value, a tag that matches a line of code, or a variable)||
||BRGTR||Branch if Greater Than||Yes||If the top of the stack is greater than 0, branch to the argument (Argument Can be an actual memory value, a tag that matches a line of code, or a variable)||
||HALT||Halt||No||Stop the Machine||

==Input/Output==
(Currently not fully implemented nor tested)
|| *Command Keyword* || *Command* || *Arguments?* || *Description* ||
||RDCHAR||Read Character||No||Read a character from the keyboard and out its ASCII value on the stack||
||RDINT||Read Integer||No||Read an Integer from the keyboard ad out it on the stack||
||WRCHAR||Write Character||No||Write the top of the stack on the screen treating as an ASCII value||
||WRINT||Write Integer||No||Write the top of the stack on the screen treating as a signed integer||